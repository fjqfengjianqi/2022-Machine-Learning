# WEEK 9

[TOC]

# 前言

什么是推荐系统？

> r表示打分与否，y表示打的分

![image-20221207165212038](./assets/image-20221207165212038.png)

# 基于协同的过滤算法-collaborative filtering algorthm

## 推荐系统的代价函数

> $w^{(j)}$跟$b^{(j)}$指的是第j个人的观影参数系统，$x^{(i)}$表示第i个电影的特征值

![image-20221207170107758](./assets/image-20221207170107758.png)

> 最后那个是防止过拟合的正则化

![image-20221207170431771](./assets/image-20221207170431771.png)

实际上消去$m^{(j)}$这一常数并不会影响太多，所以底下都去掉了，可能感觉上求和的权重不一样了，但是$w^{(i)}b^{(i)}$与$w^{(j)}b^{(j)}$之间是相互独立的，也就是说这个$m^{(j)}$权重只是影响$w^{(j)}b^{(j)}$，不会影响其他的，所以可以去掉（只是==并行计算==而已）

![image-20221207170533222](./assets/image-20221207170533222.png)

对所有用户来求（可以用到矩阵的运算）

## 协同过滤算法-Collaborative Filtering algorithm

> 当这些特征值未知时

![image-20221207171329206](./assets/image-20221207171329206.png)

实际上很像用$w$去估计$x$了，实际上就是解方程，但是要考虑最小二乘解

> 用x去估计w，b就是看一个人对不同电影的评价
>
> 用w，b去估计x则是看所有人对一部电影的评价

![image-20221207171844072](./assets/image-20221207171844072.png)

> 两者对比与总和，即同时优化wb与x

![image-20221207172818993](./assets/image-20221207172818993.png)

![image-20221207172953875](./assets/image-20221207172953875.png)

- 梯度下降法

![image-20221207173240383](./assets/image-20221207173240383.png)

实际上是在处理时利用了横纵上特征的关系来构造的一个关系式，更加符合逻辑

## 二值标签-binary labels

> 一般是喜欢或者不喜欢

<img src="./assets/image-20221207174458279.png" alt="image-20221207174458279" style="zoom: 80%;" />![image-20221207174502747](./assets/image-20221207174502747.png)

![image-20221207174812848](./assets/image-20221207174812848.png)

![image-20221207174940631](./assets/image-20221207174940631.png)

![image-20221207175108098](./assets/image-20221207175108098.png)

熟悉的交叉熵函数(01规划常用的)

![image-20221207175128902](./assets/image-20221207175128902.png)

![image-20221207175220805](./assets/image-20221207175220805.png)

# 推荐系统的实现

## 行的归一化

> 由于正则化，Eve的参数将会全是0，这并不符合预期

![image-20221207175727949](./assets/image-20221207175727949.png)

 ![image-20221207184315543](./assets/image-20221207184315543.png)

> 加了一个平均值，实际上就是把大家伙的口味给他，且只对Eve有效，因为其他人的wb不是0

归一化列表示这个新电影是否展示出来，其实没那么重要，而归一化行可以看出来这个电影的评价是怎样的

## tf实现协同过滤

Tensorflow可以直接帮你计算微积分与导数

![image-20221207184946510](./assets/image-20221207184946510.png)

![image-20221207185641719](./assets/image-20221207185641719.png)

这里中间部分是自己构造了一个$costJ$函数

![image-20221207185939437](./assets/image-20221207185939437.png)

zip的添加是为了把参数打包成组，更容易调用查阅

> 不用之前的方式实际上是因为之前的方法更多是用来拟合，而非此处差异化表现的连接，主要还是Tensorflow更加高效

## 找到相似商品

> 吴佬是个星战迷呀，课上两次出现星战了

![image-20221207190820446](./assets/image-20221207190820446.png)

实际上就是根据特征$x^{(i)}$来判断是否相似

![image-20221207191257656](./assets/image-20221207191257656.png)

![image-20221207191511776](./assets/image-20221207191511776.png)

> 很少的人评估时，我们如何推荐？如何用上更多的用户个人信息进行分析？
>
> <img align="left" src="./assets/image-20221207191702914.png" alt="image-20221207191702914" style="zoom:67%;" />

# 基于内容的过滤算法-content-based filtering algorthm

## 内容过滤vs协同过滤

更加个性化的推荐（实际上像是不仅仅是对movie打分，还有更多层的运算）

![image-20221207192050152](./assets/image-20221207192050152.png)

> - 协同过滤：就是跟你差不多的人都喜欢玩原神，我们就给你推荐原神
> - 内容过滤：就是你也喜欢原神类型的游戏，但是更喜欢主机游戏，我们就给你推塞尔达

![image-20221207192414971](./assets/image-20221207192414971.png)

> review：one-hot是[one-hot-coding](第七章-决策树与随机森林.md)一种编码方式

![image-20221207193246987](./assets/image-20221207193246987.png)

u-user,m-movie

![image-20221207193648889](./assets/image-20221207193648889.png)

In short：我有一堆人的喜好特征，一堆电影的特点，怎么match最佳(与之前的光看打分算是升级版)，下面就是怎么算$v_uv_m$

## 深度学习实现内容过滤

![image-20221207200253593](./assets/image-20221207200253593.png)

多参数输入的神经网络

![image-20221207200539607](./assets/image-20221207200539607.png)

> 这里的实际上就是之前的附近的推荐值

![image-20221207200804451](./assets/image-20221207200804451.png)

可以预先进行计算，求出来最适合的点，而不是先让客户打分然后再计算

## 从大目录中推荐

![image-20221207201522753](./assets/image-20221207201522753.png)

**genre**-种类，类型

- Step 1-**Retrieval**-检索

![image-20221207201848353](./assets/image-20221207201848353.png)

- Step 2-**Ranking**-排名

> 用模型仅对检索后的电影进行排名（减少不必要的工作量），而且只计算$v_u$即可

![image-20221207202205187](./assets/image-20221207202205187.png)

> 这样做可以让算法跑得更快，更好，但是如果加大数据量，那么还是可以冒险一试

![image-20221207202518351](./assets/image-20221207202518351.png)

## tf中实现内容过滤

- 前两行用来建立模型-relu激活函数-**max(0,x)**
- (==x==)第三行计算$v_u$并归一化（2范数为1）
- 第四行计算$v_m$并归一化（2范数为1）
- 然后取点积输出output(==y==)

![image-20221207215955027](./assets/image-20221207215955027.png)

# 社会伦理问题

> 科技的目的是让大家生活的更好

![image-20221207213433623](./assets/image-20221207213433623.png)

![image-20221207213743641](./assets/image-20221207213743641.png)

**良性循环**

<img src="./assets/image-20221207213614403.png" alt="image-20221207213614403" style="zoom:67%;" />

**恶性循环**

<img src="./assets/image-20221207213725419.png" alt="image-20221207213725419" style="zoom:80%;" />

剥削性业务的存在：**exploitative**-剥削

![image-20221207213807107](./assets/image-20221207213807107.png)

![image-20221207213953775](./assets/image-20221207213953775.png)

希望更加透明：**transparent**-透明度，**amplify**-放大，**conspiracy**-阴谋论，**toxicity**-毒性作用

**amelioration**-改进，**welfare**-福利
